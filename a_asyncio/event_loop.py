import asyncio
# про celery:
#   - использует технологию semaphore'ов
#   - допустим мы рассылаем 1000 писем, вместо того, чтобы ждать отправки
#       каждого письма и отработки каждой задачи,
#       используя декоратор celery, мы вызываем func.delay(*args)
#       и откладываем задачу в кэш, к примеру, redis,
#       дальше celery по очереди будет отрабатывать эти задачи
#       semaphore, т.к. принцип тот же: как только какая-то задача -
#       выполнена, celery добавляет следущую на выполнение
# все функции и подзадачи в asyncio должны быть асинхронными
# GIIIIL
async def f():
    while True:
        print('f() func')
        await asyncio.sleep(1)

async def g_helper():
    return 10

async def g():
    while True:
        # при вызове асинхронной функции как синхронную:
        #   - возвращает карутину
        print(await g_helper())
        # позволяет спать в asyncio
        # - await обяз иначе возвращает карутину
        await asyncio.sleep(1)


# async: 
#   - исполняется через asyncio/другие асинх. либы
#   - использует await'ы
#   - не блокирующая
async def main():
    # - create_task(func()): создаёт задачу, добавляет её в event_loop
    # - await запускает асинхронные функции и ждёт результата их исполнения
    # - f() подразумеваются как подзадача, которая не блокирует исполнение main()
    #       и недобавляется в событийный цикл
    main_loop.create_task(g())
    # если все func() создать как таски, то как только завершится main() они будут уничтожены
    # даже если ещё не были завершены, т.к. используем run_until_complete(main())
    # main_loop.create_task(f())
    await f()

# get_event_loop - берёт уже существующий событийный цикл или создаёт новый
# для создания нового: new_event_loop()
# Принцип event_loop'a:
#   - код никогда не останавливается, если какая-то функция начинает блокировать код
#       цикл переходит к следующей и возвращается к первой в самом конце, после выполнения всех а-ля стэк лифо
main_loop = asyncio.get_event_loop()

# run_until_complete(func()) - событийный цикл работает, пока не завершится func()
# g() недовыполняется, потому что main() завершится быстрее
main_loop.run_until_complete(main())

# run_forever() - событийный цикл работает всегда
# main_loop.run_forever()